<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>단어 트래킹 개선 테스트</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .highlight {
            background-color: rgba(34, 124, 255, 0.1);
            border-bottom: 2px solid #227cff;
        }
        a {
            color: #0066cc;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        strong {
            font-weight: bold;
        }
        em {
            font-style: italic;
        }
        .test-button {
            background: #227cff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px;
        }
        .test-button:hover {
            background: #0056cc;
        }
    </style>
</head>
<body>
    <h1>단어 트래킹 개선 테스트</h1>
    
    <div class="test-section">
        <h2>테스트 1: 링크가 포함된 텍스트</h2>
        <p>President Donald Trump signed an <a href="https://www.whitehouse.gov/presidential-actions/2025/08/prosecuting-burning-of-the-american-flag/">executive order</a> on Monday directing the Justice Department to pursue criminal penalties against people who "desecrate" the American flag—including by <a href="https://time.com/3907444/flag-supreme-court-history/">burning it</a>—setting up a direct collision with a landmark Supreme Court ruling that shielded such acts as protected speech.</p>
    </div>

    <div class="test-section">
        <h2>테스트 2: 볼드와 이탤릭이 포함된 텍스트</h2>
        <p>That's according to <em>Variety, </em>which <a class="link-external" href="https://variety.com/2025/film/box-office/box-office-kpop-demon-hunters-leads-box-office-over-weapons-1236497070/" rel="noopener">reported</a> on Sunday (August 24) that the film outpaced<strong> <a class="link-relationship" title="Companies > Warner Records [480 articles]" href="https://www.musicbusinessworldwide.com/companies/access-industries/warner-music-group/warner-records/">Warner Bros.</a>'</strong> horror film <em>Weapons </em>in its third weekend of release. <em>Weapons </em>was reportedly expected to claim the weekend title with <strong>$15.6 million</strong> from <strong>3,631</strong> North American theaters.</p>
    </div>

    <div class="test-section">
        <h2>테스트 3: 같은 단어가 여러 개 있는 텍스트</h2>
        <p>This week,<strong> <a class="link-relationship" title="Companies > Spotify [4,395 articles]" href="https://www.musicbusinessworldwide.com/companies/spotify/">Spotify</a></strong> expanded its publishing licensing strategy with a new multi-territory deal with <strong>amra</strong>, following its recent direct licensing agreement with <a class="link-relationship" title="Companies > Kobalt Music Group [789 articles]" href="https://www.musicbusinessworldwide.com/companies/kobalt-music-group/">Kobalt</a> in the US.</p>
    </div>

    <div class="test-section">
        <h2>테스트 4: 복잡한 HTML 구조</h2>
        <div>
            <p>This is a <span style="color: red;">complex</span> text with <strong>multiple</strong> <em>formatting</em> elements and <a href="#">links</a>.</p>
            <p>Another paragraph with <code>code</code> and <mark>highlighted</mark> text.</p>
        </div>
    </div>

    <div class="test-section">
        <h2>테스트 5: 중첩된 태그</h2>
        <p>This text has <strong>bold text with <em>italic text</em> inside</strong> and <a href="#">links with <strong>bold</strong> text</a>.</p>
    </div>

    <div class="test-section">
        <h2>테스트 컨트롤</h2>
        <button class="test-button" onclick="testWordTracking()">단어 트래킹 테스트 시작</button>
        <button class="test-button" onclick="clearHighlights()">하이라이트 제거</button>
        <div id="test-result" style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 5px;"></div>
    </div>

    <script>
        // 테스트용 단어 트래킹 함수
        function testWordTracking() {
            const resultDiv = document.getElementById('test-result');
            resultDiv.innerHTML = '<strong>테스트 시작...</strong>';
            
            // 모든 테스트 섹션에서 단어 찾기
            const testSections = document.querySelectorAll('.test-section p, .test-section div');
            
            testSections.forEach((section, sectionIndex) => {
                setTimeout(() => {
                    testSection(section, sectionIndex);
                }, sectionIndex * 1000);
            });
        }

        function testSection(element, sectionIndex) {
            const resultDiv = document.getElementById('test-result');
            
            // 텍스트에서 단어들 추출
            const text = element.textContent;
            const words = text.split(/\s+/).filter(word => word.length > 0);
            
            resultDiv.innerHTML += `<br><strong>섹션 ${sectionIndex + 1}:</strong> ${words.length}개 단어 발견`;
            
            // 각 단어를 순차적으로 하이라이트
            words.forEach((word, wordIndex) => {
                setTimeout(() => {
                    highlightWord(element, word, wordIndex);
                    resultDiv.innerHTML += `<br>단어 ${wordIndex + 1}: "${word}" 하이라이트`;
                }, wordIndex * 200);
            });
        }

        function highlightWord(element, targetWord, wordIndex) {
            // 기존 하이라이트 제거
            clearHighlights();
            
            // 단어 위치 찾기
            const range = findWordRange(element, targetWord, wordIndex);
            
            if (range) {
                // 하이라이트 적용
                const span = document.createElement('span');
                span.className = 'highlight';
                range.surroundContents(span);
            }
        }

        function findWordRange(element, targetWord, targetWordIndex) {
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let currentWordIndex = 0;
            let textNode;
            
            while (textNode = walker.nextNode()) {
                const nodeText = textNode.textContent;
                const words = nodeText.split(/\s+/).filter(word => word.length > 0);
                
                for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
                    if (currentWordIndex === targetWordIndex) {
                        // 단어 위치 찾기
                        const word = words[wordIndex];
                        const wordStart = findWordStartInText(nodeText, word, wordIndex);
                        
                        if (wordStart !== -1) {
                            const range = document.createRange();
                            range.setStart(textNode, wordStart);
                            range.setEnd(textNode, wordStart + word.length);
                            return range;
                        }
                    }
                    currentWordIndex++;
                }
            }
            
            return null;
        }

        function findWordStartInText(text, targetWord, wordIndex) {
            const words = text.split(/\s+/).filter(word => word.length > 0);
            
            if (wordIndex >= words.length) {
                return -1;
            }
            
            let currentPos = 0;
            
            for (let i = 0; i <= wordIndex; i++) {
                const word = words[i];
                const wordStart = text.indexOf(word, currentPos);
                
                if (wordStart === -1) {
                    currentPos += word.length + 1;
                    continue;
                }
                
                if (i === wordIndex) {
                    return wordStart;
                }
                
                currentPos = wordStart + word.length;
            }
            
            return -1;
        }

        function clearHighlights() {
            const highlights = document.querySelectorAll('.highlight');
            highlights.forEach(highlight => {
                const parent = highlight.parentNode;
                parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
                parent.normalize();
            });
        }
    </script>
</body>
</html>
